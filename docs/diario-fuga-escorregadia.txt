2013-11-13
==========
- Inaugurei a nova fase do projeto Fuga Escorregadia!
- Criei a estrutura básica do projeto
- Estou fazendo TDD/BDD direitinho, do zero
- Criei o assert

Reflexões
---------
- Gastei bastante tempo criando a estrutura básica e o assert

Retrospecto
-----------
- Melhorei um pouco o foco em resultado, mas ainda preciso melhorar mais


2013-11-15
==========
- Andei preocupado com a escolha da licença. Quero usar LGPL para o FE, mas MIT para as bibliotecas.
- Percebi que o problema está em tocar diversos projetos juntos, tipo o assert e o FE
- Então, li sobre gestão de dependências em JS. Conclusões:
  - é complexo...
  - ferramentas úteis: Yeoman, Grunt, Bower
  - vou deixar para depois
- Vou seguir do jeito como está, por enquanto

- Finalmente consegui usar o shim do RequireJS!
- Posicao, Direcao, Movimentacao

2013-11-17
==========
- Programei na TV com Vivinha!
- Fizemos a movimentação com obstáculo
- Tornei Movimentacao sem estado

- Próximos passos:
  - mudar de posicao(l, c) para repoPosicoes.obter(l, c) ou algo assim

2013-11-20
==========
- Coloquei projeto no BitBucket. Facinho!
- RepoPosicoes em ordem

2013-11-27
==========
- Vou mexer na movimentação, acrescentando novos elementos
- Surgiu necessidade do enum; acrescentei-o ao projeto
- enum ficou bem legal, com uma interface extremamente usavel

2013-12-04
==========
- Ajeitei o código de movimentarPersonagem. Agora está em ordem e bem limpo.
- enum agora aceita definir propriedades para serem herdadas

2013-12-06
==========
Lugar
-----
- Vim programar no parque! Cheguei umas 9h40 e comecei efetivamente umas 10h.
- Está sendo muito bom!
	- Quando estou concentrado, nem lembro que estou aqui
	- Mas, quando paro um pouco, tenho um ótimo ambiente para olhar e sentir
- Tem uns bichinhos vindo em mim de vez em quando, mas tudo bem!

Diário
------
- Será muito útil anotar algumas decisões aqui no diário
- Futuramente, pretendo palestrar sobre o desenvolvimento do FE. Nesse dia,
  essas anotações serão muito úteis.

Testes de unidade ou de integração?
-----------------------------------
- Percebi que a MovimentacaoSpec começou a querer dar trabalho
- Ela estava sendo um teste de integração com o enum Elemento
- Pô, mas testar um enum? Não seria granular demais?
- Concluí que não. Fazendo a spec do Elemento, a da Movimentacao ficará
  muito simples. Vai compensar.
- Pensei também em Deméter: quando você fura a lei de Deméter, você
  tende a complicar os dublês
- No meu caso, é o tabuleiro. O jeito Deméter seria
  tabuleiro.elementoPermitePassagem(linha, coluna, direcao). Achei que
  ficaria estranho... Melhor fazer tabuleiro.obterElemento(linha, coluna)
  .permiteEntrarVindoDe(direcao), mesmo.
- Pensando bem, talvez respeitar Deméter dê um resultado melhor...
  Senão, terei que fazer dois stubs em vez de um. Se eu fizer do jeito
  Deméter, a classe Movimentacao terá ainda menos responsabilidades,
  pois dividirá algumas delas com a nova classe Tabuleiro.
- E, como eu preciso de um stub legal e o Jasmine não oferece, vou esperar
  chegar em casa, e aí eu vejo se o Sinon tem algo tipo o do Mockito.

ElementoSpec
------------
- Os testes começaram a ficar repetitivos e a dar trabalho. Então, tentei
  criar a constante TODAS_DIRECOES usando o padrão Composite, para facilitar
  tudo. Mas não deu certo, daria muito trabalho, não compensaria.

Pendências
----------
- Mudar MovimentacaoSpec para usar os stubs em vez dos elementos de verdade
- Terminar de refatorar ElementoSpec para ficar mais simples e legível

- permiteSairLogoAposEntrar talvez devesse receber direcao

2013-12-07
==========
- Continuei tentando fazer os DirecaoMatchers

2013-12-08
==========
- Continuei tentando fazer os DirecaoMatchers
- Ficou complexo. Mas funcionou. Vamos ver com o tempo se vale a pena manter.
- Estou começando a achar que fazer TDD 100% do tempo pode não ser uma boa
- Percebi que o problema não é o TDD, e, sim, querer exaurir as possibilidades.
  Preciso pensar mais em nível de confiança do que em exaustão de possibilidades.

- Nada de stubs: usei Elementos de verdade. Bem melhor!
- Agora, vou para o ITEM!

- Está começando a querer precisar do delegate, vide Elemento delegando para EventoElemento
- Viajei um pouco nos enums e nas divisões de responsabilidades, mas acho que ficou razoável.
  Sigamos assim e vejamos aonde dá.
- FabricaEventos está com métodos estáticos. Talvez valesse a pena transformar em de instância.

- Ficou só uma coisa estranha: COLA tem como _eventoAoEntrar: EventoElemento.CONTINUACAO_MOVIMENTO,
  e não é verdade. O EventoElemento seria BLOQUEAR_MOVIMENTO. Aí impacta na possível refatoração
  da Movimentacao, para que toda a lógica de construção do eventosMovimento seja feita em
  EventoElemento.aoEntrar. Precisa avaliar se seria uma boa.

2013-12-11
==========
- Briguei com o Jasmine até que que descobri que ele imprime o toString do objeto, mas tem que ser
  jasmineToString em vez de toString. Resolvi alterar o código e permitir toString também.
- Fiz a classe ResultadoMovimento, que simplificou a geração do resultado do movimento pela classe
  Movimentacao. Ficou bem legal.
- Também tornei a MovimentacaoSpec mais legível. Ficou bem fácil de entender o que ela faz!

- Agora quero fazer uma view simples, em modo texto, para um mapa
- E também organizar os arquivos em diretórios, porque já está começando a virar uma bagunça
- Ainda não fiz também a SAIDA, que talvez eu devesse renomear para CHEGADA ou algo assim,
  para nao confundir com o conceito de SaidaJogo

2013-12-25
==========
- Retomei o projeto após duas semanas
- Mexi no CompiladorMapa
- Modifiquei o enum para aceitar construtor e métodos estáticos
- Para o enum ficar 100%, faltaria o seguinte:
    - Verificar situações excepcionais (muito fácil de acontecer, já que a API aceita diversas possibilidades)
    - Construtor fornecido já está sendo chamado. Fazer com que ele seja usado para instanciar as constantes.
    - Fazer specs para quando se misturam diferentes funcionalidades do enumerate

2014-02-04
==========
- Retomei após um mês e pouco
- Achei várias coisas confusas! Principalmente a parte de elementos, aquele encapsulamento todo,
- ResultadoMovimento está mais confundindo do que ajudando
  EventoElemento, DirecaoMatcher etc.
- O negócio é focar no negócio, mesmo. E esquecer um pouco esses detalhes de implementação.
- Refatorar stringMapas para ficarem assim --> [['_ p _'], ['_ _ _']] ou assim '_ p _' + '_ _ _'? 

2014-05-18
==========
- Próximo do meu aniversário, retomei após três meses
- Quis configurar para rodar testes automaticamente após salvar
- O Karma deu bastante dor de cabeça e, no fim, só detectou a primeira vez em que
  o arquivo era salvo. A partir da segunda, não funcionava mais.
- Deu certo com Grunt + grunt-contrib-watch + grunt-jasmine-node. Pequenos problemas:
    - Configuração meio complicada
    - Não consegui ocultar stacktrace
- Próximos passos
    - Tentar com Gulp
    - Tentar com https://github.com/danilobellini/dose (conferir se GPL dá problema)
    - Decidir por algum e seguir a vida

2014-05-22
==========
- Quinta-feira, das 9 às 12h
- Dose: não consegui configurar. Reclama de falta de pacotes.
- growl: biblioteca para node para usar notificação do SO.
- jasmine-node: simplesmente não funciona. Não faz nem um hello, world.
- gulp-jasmine: quase funcionou. Faltou lidar com RequireJS.
    - Pensei nesta solução: global.define = require('requirejs').define;
- Agora falta resolver o problema do módulo anônimo
- Estranhamente, não deu mais problema com módulo anônimo, nem o
  problema da falta do define no escopo global. Acho que resolveu quando
  eu passei a chamar requirejs() em vez de tentar carregar direto
  o arquivo de spec.

- Conclusões:
    - A função requirejs(), no navegador, aceita um vetor de dependências.
      No Node, aceita somente uma string, que é uma única dependência.
      Resultado: muita dor de cabeça para descobrir isso e a solução foi
      criar um spec-runner específico para quando for usar Node.
    - Comando gulp test finalmente funcionou. Mas o watch ainda não
      está funcionando. Ele só pega a primeira alteração no sistema de
      arquivos. A partir da segunda, ele não roda mais nenhum teste.
      Diz "0 teste, todos passaram". Precisa investigar isso.
    - Quando resolver isso, integrar com o growl para gerar notificações.
    - Remover duplicações entre spec-runner-html e spec-runner-node.

2014-05-25
==========
- Após 2 a 3h de trabalho, finalmente consegui resolver todos os problemas
  e obter o retorno imediato pelo terminal
- Não cheguei a conseguir aproveitar a saída do Jasmine para chamar o growl()

2014-05-27
==========
- Vamos começar os testes de integração usando jQuery
- Descobri o jsdom, que parece perfeito para fazer os testes de jQuery e DOM
  direto no Node
- No meio do caminho, fui refatorar uns negócios de módulos e caí de novo em
  problemas de configuração do RequireJS
- Desencanei do shim padrão. Escrevi meus próprios wrappers para underscore e
  jQuery, expondo-os como módulos AMD.
- Fiz um require-js-configuracoes-globais

2014-06-01
==========
- Pesquisei sobre Jasmine 2.0 e alternativas ao Jasmine
- Mocha tem vantagens, mas também parece ter seus defeitos
- Não vai valer a pena mudar agora. Em vez disso, vou voltar a tentar aplicar o
  growl() eu mesmo de alguma maneira.
- Pelamordedeus, essas ferramentas são muito mal-feitas... O Jasmine não explica
  nada sobre como criar seu próprio reporter. Tentei olhar o código para entender
  e também não entendi. Não explica nada direito. Quase desisti.
- Descobri um problema no gulp-jasmine/minijasminenode e mandei um pull request
- Consegui integrar com o Jasmine, depois de muito trabalho. Mas não adiantou nada,
  porque o notify-send do Ubuntu deixa a mensagem fixa por 5 segundos, não permitindo
  trocá-la imediatamente. Em outras palavras, foi tudo por água abaixo.


2014-06-02
==========
- Novamente, tomei migué das ferramentas. No caso, o jQuery não quis rodar junto
  com RequireJS + Node. Só no Node, roda. Só com RequireJS, roda. Com os dois juntos,
  dá pau. Exceto quando eu fui criar um caso de teste para submeter um defeito para
  o jQuery!
- require('requirejs')('jquery') funciona.
  require('requirejs')('./caminho/jquery') não funciona.
- jQuery faz define('jquery', [], function ...) e ainda justifica dizendo que, por
  ser uma biblioteca muito usada, tudo bem...
- Pensei em buscar alternativas ao RequireJS:
    - http://browserify.org/
        - Depoimento aqui: http://esa-matti.suuronen.org/blog/2013/03/22/journey-from-requirejs-to-browserify/   
    - Sugestões do @srsaude:
        - curl.js
        - almond.js
        - bdLoad
        - UMD
- Descobri um negócio muito legal para desenvolver aplicativos desktop com NodeJS:
  node-webkit:
    - https://speakerdeck.com/zcbenz/node-webkit-app-runtime-based-on-chromium-and-node-dot-js
    - https://github.com/rogerwang/node-webkit

2014-06-05
==========
- Desenvolvendo no Windows 8.1
- Instalar Node e NPM foi fácil
- Comecei tentando a nova técnica para incluir jQuery: testo com if (typeof global !== 'undefined') para
  se estou no Node. Se sim, faço require('jquery'). Se não, faço o define normal.
- Só que esbarrei na instalação do jsdom. Não consegui instalá-lo, mesmo após quase 2h tentando.
- Segundo https://github.com/tmpvar/jsdom#contextify, jsdom exige:
    Visual C++ 2010 Express              --> http://www.visualstudio.com/downloads/download-visual-studio-vs#d-2010-express
    Python 2.7, instalado em C:\Python27 --> https://www.python.org/download/
- Cansei-me dele, procurei uma alternativa e descobri o cheerio: https://www.npmjs.org/package/cheerio
- Cheerio parece muito melhor. Vou tentar usá-lo no lugar do jQuery e do jsdom.

2014-06-06
==========
- Cheerio funcionando perfeitamente bem, para minha alegria! Foi de primeira!
- MapaViewHtmlTableSpec iniciada
- Esbocei a tela do jogo

2014-06-12
==========
- Quis fazer alguma coisa em CoffeeScript, tipo o gulpfile, mas o plugin para
  Eclipse não ajudou. Então, vou continuar com JS, pelo menos por enquanto.
- Mudei MapaViewHtmlTable para usar tabela
- Descobri que cheerio não suporta :eq. Isso já foi relatado:
  https://github.com/cheeriojs/cheerio/issues/129#issuecomment-45910233 
- Refleti sobre se devo ou não "testar o CSS"; na verdade, se devo testar que o HTML
  gerado na classe MVMT possui as classes CSS certas etc. Cheguei à seguinte conclusão:
    - "Testar CSS" em JS realmente é algo estranho. Porém, testar se o HTML é gerado
      na estrutura correta, com a tabela, com as posições corretas etc. não é testar
      HTML ou CSS, é testar se o código JavaScript faz seu trabalho corretamente.
    - Já escrever uma spec para ver se a tabela possui a classe esperada parece um
      pouco de exagero. Ainda assim, talvez, valha a pena.
    - Aliás, vou fazer isso!
- Coloquei um _.throttle no gulpfile para evitar o problema de rodar testes 
  repetidamente e capotar o gulp quando fizer CTRL+H para localizar e substituir
  em diversos arquivos.
- Fui renomear os htmls e pontos de entrada do sistema. No meio do caminho, percebi
  que é bem difícil pensar numa nomenclatura unívoca. Percebi que eu poderia cair
  em Shotgun Surgery e coisas parecidas. Também refleti bastante sobre a eterna
  dúvida: unidade ou integração? Encapsular ou injetar dependência? Enfim, desisti
  por enquanto.

2014-06-13
==========
- Estou continuando a MVMTSpec
- Tive uma dúvida: ResultadoMovimento deve dizer de onde o personagem sai ou saber
  isso é responsabilidade de MVMT?
- Estou percebendo que meu design está meio estranho; está faltando uma classe
  Tabuleiro. Preciso fazer um diagrama de classes novo e pensar melhor na
  responsabilidade de cada classe, quais guardam estado e quais não guardam.

2014-06-14
==========
- Redesenhando as classes
- MVMT (MapaViewModoTexto) foi renomeado para MVHT (MapaViewHtmlTable)
- CompiladorMapa vai gerar um MapaModel
- MapaModel, inicialmente, nao tinha testes de unidade, pois seria Value Object,
  muito simples para isso. Mas logo surgiu a necessidade de um metodo paraCada,
  e aí foi interessante especificar seu comportamento.
- É a velha reflexão: unidade ou integração? É importante haver testes para tudo.
  A granularidade vai determinar a facilidade de entender o teste e a classe,
  mas a cobertura pode ser garantida com um teste indireto, de integração, mesmo.
- FabricaEventos está com métodos estáticos, como citado aqui no diário em dezembro
  do ano passado. Porém, refleti sobre o seguinte:
    - É só uma fábrica de Value Objects. A chance de ter que mocar é praticamente nula.
    - Mantendo estático, é possível fazer uns static imports, o que ajuda legal
    - Então, vou manter estático por enquanto e ainda fazer static imports 
- MVHTSpec:
  - Faz sentido criar um método processarMovimento(de, para)? Não deveria receber
    um ResultadoMovimento e processá-lo?
  - A questão é que, supostamente, deveria receber a posição atual do personagem,
    conforme rascunhado em papel:
    - JogoModel --> MapaModel(resultadoMovimento)
      JogoModel --> MapaView(posicaoPersonagem, resultadoMovimento)
- Mesclei CompiladorMapa com MapaModel, ficando só com essa última

2014-07-03
==========
- Agora, no Windows!
- Gastei um tempão formulando a explicação de como configurar o ambiente
- Essa foi uma experiência interessante:
  - Percebo que dá trabalho explicar com clareza e simplicidade
  - Ainda assim, vale a pena! É a diferença entre as pessoas conseguirem e não
    conseguirem realizar uma tarefa.

2014-07-04
==========
Etapa 1
-------
- Mexi em MapaViewHtmlTable, no método processarResultadoMovimento(origemPersonsagem, resultadoMovimento)
- Segui o lema "barra verde o mais rápido possível". Aconteceu da seguinte maneira: #valordotdd
  - Esse método trabalhava com um vetor de EventoMovimento
  - Para alcançar a barra verde o mais rápido possível, eu fiz resultadoMovimento[0]._posicaoDestino
  - Isso era bem feio. Eu precisaria limpar em algum momento.
  - No meio do caminho, o que aconteceu? Percebi que, para eliminar duplicação, eu teria que
    fazer um for passando por todos os elementos do vetor. Não havia nenhum teste exigindo isso.
    Seria uma "refatoração" com cara de nova funcionalidade.
  - Isso era sinal de que havia algo errado. O que?
    - Simples: eu estava fazendo um método estranho, difícil de testar. Na verdade, o que eu queria
      não era um processarResultadoMovimento, e, sim, movimentarPersonagem.
    - Esse foi facinho de testar e não exigiu a gambiarra do [0]._propriedadePrivada
  - Resumindo, o "barra verde o mais rápido possível" me possibilitou enxergar um defeito no meu design,
    que eu dificilmente teria enxergado se tivesse partido para a solução final de uma vez, que seria
    fazer o for, publicar algumas propriedades que estavam privadas, rever as classes de EventoMovimento
    etc. Nada disso era o que eu queria fazer. O que eu queria fazer era tratar um movimento simples.
- Na prática, agora eu vou ter que escrever uma camada que traduza ResultadoMovimento para chamadas
  aos métodos de MapaViewHtmlTableSpec. Esse é um pequeno trabalho perto do ganho em testabilidade
  e compreensibilidade.
  
Etapa 2
-------
- Achei o método Posicao.prototype.eh meio estranho. Ele só serve para facilitar testes. Não deveria
  estar na classe de domínio, e, sim, no arquivo de spec. Logo, refatorar a "classe" de testes.
- Outra refatoração legal para "classes" de teste é substituir umas "variáveis mágicas" que eu criei
  (como aPosicao = _(Posicao.prototype.obter).bind(new Posicao())) por funções locais, com a mesma
  funcionalidade

Etapa 3
-------
- Corrigi um negócio no Eclipse que estava me impedindo de fazer CTRL+2, R
- Novamente, #valordotdd: tentei refatorar no vermelho e me perdi. Voltei ao verde e encontrei
  um defeito no que eu estava fazendo
- Eu estava pensando em, por praticidade, manter o uso das strings 'PERSONAGEM' e 'NADA' em vez de
  importar as constantes do enum e usá-las. Quebrei a cara: commitei esse 'NADA', só que, na verdade,
  a constante se chama VAZIO! E o teste tinha passado... #valordasboaspraticas
- Fui criar o método valueOf em enumerate.js e depois lembrei que esse método já faz parte do JavaScript.
  Então, vou ter que inventar outro nome.
- #valordotdd: fui fazer uma implementação demorada, do método Enum.forName, escrevendo um for. Coloquei
  um throw '' para o teste passar, porque ele esperava uma exceção. Resultado: não passou. E eu me
  perdi. Quando voltei atrás, fiz o que eu não queria ter feito: um horrível
  if (name === 'OEE') throw ''; só para o teste passar. Resultado? Não passou! Mas throw 3; fez o teste
  passar. Conclusão: não se deve fazer throw com string vazia.
- #valordotdd: realmente, esse negócio de implementação falsa que progressivamente se torna a
  implementação verdadeira é muito útil para gerar mensagens de erro. Concatenação de strings geralmente
  é um negócio muito sujeito a erros. Partir da constante para a expressão sem duplicação realmente
  é muito mais fácil passo-a-passo. Senti isso ao gerar a mensagem de erro em Enum.forName.

2014-07-05
==========
- Pensei em mudar de Mapa para Tabuleiro quando for mutável e chamar de Mapa só o mapa imutável
- Vou fazer isso, pois distribui melhor as responsabilidades
- Percebi que, quando apaguei o CompiladorMapa, apaguei junto as specs negativas
- Fiz uma volta grande para voltar a usar, efetivamente, o CompiladorMapa, agora chamado somente
  de Mapa. Mas tem praticamente o mesmo efeito.

2014-07-06
==========
- Fui tentar o Growl for Windows, o Defender disse que tinha vírus...
- Mais uma config útil no Eclipse:
    - JavaScript/Editor/Content Assist/Advanced/Other JavaScript Proposals: desmarcar
    - Isso elimina umas sugestões malucas quando você faz CTRL+Espaço
- Mexi nos build path da vida do Eclipse, excluindo src/lib das validações.
  Tchau, erros e avisos nada a ver!
- Pensei sobre o teste que estou escrevendo, com mocks, e percebi que vou precisar criar a classe
  Interface, que se comportará como a interface em Java. O motivo é o seguinte:
    - O teste cria um jasmine spy. Na criação, especificam-se nomes de métodos para mocar.
    - Porém, o que acontece? Você pode pôr um nome qualquer, que não necessariamente
      seja o mesmo que o da sua classe de verdade.
    - Com isso, o teste de unidade pode, mas não significar nada a respeito das classes
      de verdade. Uma renomeação de método mal-feita é suficiente para quebrar testes
      e não classes de produção ou vice-versa.
- Outra alternativa é fazer logo um teste de integração, que talvez seja até mais fácil
- #reflexaotdd Outra questão é se métodos cuja necessidade surge na integração deveriam constar
  nas specs de unidade. Conceitualmente, eles não são necessários no âmbito da unidade.
- #reflexaotdd Estou aprendendo que é muito importante postergar pequenas decisões. Primeiro, faça
  todos os testes relevantes passarem. Depois, refatore para ficar bonito. Isso é comum dentro de
  um ciclo de TDD: faça funcionar, depois deixe bonito. Porém, isso também serve para, por exemplo,
  um dia inteiro de trabalho. Em vez de buscar o melhor design, faça algum rapidamente e gaste
  algumas horas refatorando para ficar legal. Fazer isso depois é mais fácil, pois os requisitos
  já ficaram mais claros.
- #valordotdd Percebo que escrever a linha do assert antes às vezes te coloca de cara com uma
  decisão difícil, antes mesmo de você ter tido que fazer o código compilar. Isso acabou de acontecer
  quando eu fui escrever uma nova spec para TabuleiroModel que delegaria uma chamada para
  Movimentacao. Essa chamada de delegacao seria meio estranha; logo, meu design talvez não esteja bom.
- #reflexaotdd Ao escrever o assert primeiro, estou percebendo que é importante escrever logo
  a linha que exercita o objeto. Agora há pouco eu saí fazendo o teste passar e refatorando e acabei
  me perdendo em qual era o meu objetivo.
- #valordotdd Passos curtos. Eu jurava que uma refatoração simples de substituir um repoPosicoes.obter
  por aPosicao iria funcionar. E não funcionou. Porque o objeto repoPosicoes estava sendo injetado
  como dependência, e, na linha que criava o aPosicao, eu criei outra instância. Será que eu teria
  tido paciência de mandar um ALT+TAB, F5 só para testar esse pequeno passo?
- Finalmente lembrei por que eu criei uma classe Movimentacao independente de TabuleiroModel. É porque
  é muuuito mais fácil testar sem guardar o estado da posição atual do personagem! Havendo um método
  que simplesmente receba a posição atual do personagem e o mapa, você faz outra chamada e já está
  fazendo um novo teste. Não é necessário configurar nada. Apesar de que um simples stub resolveria
  razoavelmente bem esse problema... Bom, na prática, não ficaria tão ruim, não. É apenas
  um mock a menos.

2014-07-10
==========
- Fui fazer um simples inline local variable. Dei um passo de cada vez. No primeiro, já falharam
  os testes! Fui ver e a variável não tinha escopo onde eu queria usá-la. #valordotdd
- #reflexaotdd Esses dias andei refletindo muito sobre testes de unidade e de integração. Será que os
  de unidade deveriam cobrir tudo relativo a unidade? Ou será que uma parte deveria ser coberta pelos
  testes de integração?
- Aí, hoje, testes de integração tiveram falhas difíceis de rastrear. Pensei "Bom, o teste de
  integração realmente está pegando coisas que o de unidade não pegou". Quando investiguei melhor,
  descobri algo desagradável: meu teste de unidade que usava mock estava pouco confiável. Simplesmente
  verifiquei se certas chamadas foram feitas e com quais argumentos, mas não verifiquei a quantidade
  e a ordem das chamadas. Sempre desconfiei que isso pudesse dar problema, e hoje descobri, na prática,
  que realmente pode.
- O negócio é usar a string de captura lá do Kent Beck, que captura tudo e com ordem definida
- Decepção de novo... Não havia nada de errado com aquelas chamadas. Eu é que tinha iniciado minha
  string com '' fora do beforeEach. Refleti bastante sobre essa estrutura de specs do Jasmine
  comparada com a do JUnit. Conclusão? Nenhuma das duas é lá muito orientada a objetos... Eu tentaria
  algo assim: tipo a do JUnit, mas com início de campos no construtor e execução de todos os métodos
  públicos. Nada de @BeforeClass com método estático, nem campos estáticos, nem mesmo qualquer
  anotação para indicar que tal método é de teste. É público? É de testes.
- Hoje, acho que pela primeira vez, eu usei o debugger. Isso foi quando eu encontrei defeitos. Os
  testes de unidade pareciam em ordem, mas o de integração falhou. Como eu não estava criando a
  funcionalidade naquele momento, fiquei perdido. Acho que é normal.
- O jQuery no navegador está dando problema, não sei por quê. Parece que coisas simples como substituir
  .children('td') por .find('tr') resolvem. Precisa investigar.

2014-07-21
==========
- Estou usando o note Dell. Está travando de vez em quando.
- Rodei as specs e há dois erros:
    - Model não está se atualizando - nem deveria, porque ainda não fiz isso
    - View não está sendo atualizada - deveria, porque já fiz isso
- Era burrice minha, mesmo...
- Vamos agora corrigir o problema do Model não se atualizar
- Spies do Jasmine são chatos, mas até que estão funcionando
- Precisamos de uma fábrica de ResultadoMovimento. Vai ser chato criá-la, mas está mais chato ficar
  sem ela. Estou pensando em criar uma que use strings.
- Se fizer com strings (algo tipo resultadoMovimento('parteDe(0, 0) vaiPara(0, 1) pegaItem()')), vai dar
  uma trabalheira para fazer um negócio que serve só para testes. Vai precisar, supostamente, TDDzar
  isso aí, sendo que é mero detalhe de implementação, e não um requisito.
- Melhor ignorar essa hipótese e usar o que já temos, mesmo:
    new ResultadoMovimento(
          aPosicao(0, 0), [movimentoPara(aPosicao(2, 0)), item(), movimentoPara(aPosicao(4, 0))])
- Estou percebendo que eu tenho a cabeça muito em Java. Toda hora quero usar interfaces.
  Toda hora sinto falta da segurança da estaticidade da linguagem.
- Resolvi modificar TabuleiroModelSpec de unidade para integração. Muito mais fácil lidar com
  um objeto Movimentacao real do que com um dublê.
    - Isso pode ser um indício de que eu deveria mesclar essas duas classes
- Conclusão do dia: isolar unidades pode dar mais trabalho do que testar em integração.
  Senti isso fortemente com relação a esse monte de Value Objects com que estou trabalhando.
  ResultadoMovimento, EventoMovimento, Posicao... Compensa muito mais instanciar os de
  verdade do que ficar trabalhando com dublês. Fico sendo obrigado a criar fábricas para tudo,
  e aí vira um saco ficar importando esse monte de fábricas e static imports.
    - Eu isolei demais as coisas. Tive um trabalho enorme (por ser em uma linguagem dinâmica e
      sem muita ajuda do IDE), e agora estou vendo que talvez a integração seja um caminho mais
      simples.
    - Também estou sentindo que fazer BDD de verdade, escrevendo testes de fora para dentro,
      tende a simplificar o código dos testes, focando mais em requisitos do que em detalhes
      de implementação. Aí talvez fique mais claro onde compensa fazer unidade e quando compensa
      fazer integração. Do jeito como eu fiz, fiz de dentro para fora; de unidade para integração.
      Assim, demorei para perceber quando alguns testes não ficaram legais.
- Apesar de o teste, a rigor, ser de integração, ele não é tão de integração quanto o da View
  ou do M+V+C. Então, vou continuar chamando-o de unidade. Qual é o limite que separa unidade
  de integração? #tdddúvida

2014-07-22
==========
- Senti uma vontade enormde de refatorar algumas coisas:
    - Criar o fabricarAPosicao
    - Criar o ResultadoMovimentoBuilder
- Depois de um tempão para conseguir criar o ResultadoMovimentoBuilder, descobri que ele ficou muito
  parecido com algo que já existia: os métodos estenderMovimentoPara e coletarItem da classe
  ResultadoMovimento. Aparentemente, essa necessidade de representar um ResultadoMovimento pronto
  (ou seja, construir um inteiro de uma vez) é quase a mesma de construir um aos poucos.
